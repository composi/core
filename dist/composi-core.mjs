const a=0,b=3,c={},d=[],e=[];function f(a,b,c,d,e=null,f=null){return{type:a,props:b,children:c,node:d,flag:f,key:e}}function g(a,e){return f(a,c,d,e,null,b)}function i(a,b,...c){b=b||{};let d;const e=[],h=[];let i=c.length;const j=b.key;for(;0<i--;)e.push(c[i]);for(b.children&&(0>=e.length&&e.push(b.children),delete b.children);0<e.length;)if(Array.isArray(d=e.pop()))for(let a=d.length;0<a--;)e.push(d[a]);else if(!1===d||!0===d||null==d);else h.push("object"==typeof d?d:g(d));return"function"==typeof a?a(b,h):f(a,b,h,null,j)}function h(a,b){return JSON.stringify(a)!==JSON.stringify(b)}function j(c,a){return Object.assign({},c,a)}function k(a){this.handlers[a.type](a)}function l(a,b,c,d,e){if("key"===b);else if("style"===b&&"object"==typeof d)for(let e in j(c,d)){const c=null==d||null==d[e]?"":d[e];"-"===e[0]?a[b].setProperty(e,c):a[b][e]=c}else"o"===b[0]&&"n"===b[1]?((a.handlers||(a.handlers={}))[b=b.slice(2)]=d)?!c&&a.addEventListener(b,k):a.removeEventListener(b,k):"list"!==b&&"form"!==b&&"type"!==b&&"draggable"!==b&&"spellcheck"!==b&&b in a&&!e?a[b]=null==d?"":d:null==d||!1===d?a.removeAttribute(b):a.setAttribute(b,d)}function m(a,c,d){const e=a.type,f=a.flag===b?document.createTextNode(e):(d=d||"svg"===e)?document.createElementNS("http://www.w3.org/2000/svg",e):document.createElement(e),g=a.props;for(let b in g.onmount&&c.push(function(){g.onmount(f)}),g)l(f,b,null,g[b],d);for(let b=0,e=a.children.length;b<e;b++)f.appendChild(m(a.children[b],c,d));return a.node=f}function n(a){return null==a?null:a.key}function o(a){for(let b=0,c=a.children.length;b<c;b++)o(a.children[b]);const b=a.props.ondestroy;return null!=b&&b(a.node),a.node}function p(a,b){const c=function(){a.removeChild(o(b))},d=b.props&&b.props.onunmount;null==d?c():d(b.node,c)}function q(c,d,f,g,k){if(f===g);else if(null!=f&&f.flag===b&&g.flag===b)f.type!==g.type&&(d.nodeValue=g.type);else if(null==f||f.type!==g.type)d=c.insertBefore(m(g,e,k),d),null!=f&&p(c,f);else{let b,c,o,r;const s=f.props,t=g.props,u=f.children,v=g.children;let w=0,x=0,y=u.length-1,z=v.length-1;for(let a in k=k||"svg"===g.type,j(s,t))if(("value"==a||"selected"==a||"checked"==a?d[a]:s[a])!==t[a]){l(d,a,s[a],t[a],k);const b=t.onupdate;null!=b&&h(s,t)&&e.push(function(){b(d,s,t)})}for(;x<=z&&w<=y&&null!=(o=n(u[w]))&&o===n(v[x]);)q(d,u[w].node,u[w++],v[x++],k);for(;x<=z&&w<=y&&null!=(o=n(u[y]))&&o===n(v[z]);)q(d,u[y].node,u[y--],v[z--],k);if(w>y)for(;x<=z;)d.insertBefore(m(v[x++],e,k),(c=u[w])&&c.node);else if(x>z)for(;w<=y;)p(d,u[w++]);else{let e,g,h;for(e=w,g={},h={};e<=y;e++)null!=(o=u[e].key)&&(g[o]=u[e]);for(;x<=z;){if(o=n(c=u[w]),r=n(v[x]),h[o]||null!=r&&r===n(u[w+1])){null==o&&p(d,c),w++;continue}null==r||f.flag===a?(null==o&&(q(d,c&&c.node,c,v[x],k),x++),w++):(o===r?(q(d,c.node,c,v[x],k),h[r]=!0,w++):null==(b=g[r])?q(d,c&&c.node,null,v[x],k):(q(d,d.insertBefore(b.node,c&&c.node),b,v[x],k),h[r]=!0),x++)}for(;w<=y;)null==n(c=u[w++])&&p(d,c);for(let a in g)null==h[a]&&p(d,g[a])}}return g.node=d}function r(d){return d.nodeType===b?g(d.nodeValue,d):f(d.nodeName.toLowerCase(),c,Array.prototype.map.call(d.childNodes,r),d,null,a)}function s(a,b){!a.vdom&&b.props.onmount&&e.push(function(){b.props.onmount(a)});const c=q(a.parentNode,a,a.vdom||r(a),b).vdom=b;for(;0<e.length;)e.pop()();return c}function t(a,b){if(Array.isArray(a))throw"Cannot insert Fragment tag directly into DOM.";let c="";if("string"==typeof b&&(c=b,b=document.querySelector(b)),!b){let a="";c&&(a=` The selector you provided was: "${c}"`),console.error(`@composi/core Error: The second parameter for render function was invalid. Check the selector you provided and make sure that it exists in the DOM before trying to render. ${a}`)}s(b,a)}function u(a){function b(a){if(j)return c(f(i,a,b))}function c(a){a?i=a:d&&(i=d()),g&&k&&("function"==typeof g&&g(l,b),k=!1),e(i,b)}let d=a.init;const e=a.view,f=a.update,g=a.subscriptions||a.subs,h=a.done;let i,j=!0,k=!0;const l=()=>i;return a.send=b,c(i),()=>{j&&(j=!1,h&&h(i))}}const v=Object.prototype.hasOwnProperty;function w(a){const b=Object.create(null);for(let c=0;c<a.length;){const d=a[c];b[d]=a=>({type:d,data:a}),c++}return{variants:b,match:function(a,b){return a.type?((a,c)=>{const d=a.type,e=v.call(b,d)&&b[d];return e(a.data,c)})(a):(console.error("The message you provided was not valid. Messages have the format: {type: 'whatever', data: 'something'}"),console.error("The tag you provided was:"),void console.dir(a))}}}function x(...a){const{variants:b,match:c}=w(a);return b.match=c,b}const y=(...a)=>(b,c)=>a.map(a=>a&&a(b,c)),z=y,A=(a,b)=>Array.isArray(a)&&!b?a:b;export{i as h,t as render,u as run,x as union,y as batchEffects,z as batch,A as Fragment};
//# sourceMappingURL=composi-core.mjs.map
