{"version":3,"file":"composi-core.js.map","sources":["../src/constants.js","../src/vnode.js","../src/vdom.js","../src/union.js","../src/effects.js","../src/h.js","../src/render.js","../src/runtime.js","../src/fragment.js"],"sourcesContent":["/**\n * Used to determine if a vnode should be recycled.\n * @type {number}\n */\nexport const RECYCLED_NODE = 0\n\n/**\n * Used in a vnode to indicate that it is a DOM node.\n * @type {number}\n */\nexport const ELEMENT_NODE = 1\n\n/**\n * Used in a vnode to indicate that it is a text node.\n * @type {number}\n */\nexport const TEXT_NODE = 3\n\n/**\n * Namespace for SVG elements with `xlink:href` attributes.\n * @type {string}\n */\nexport const XLINK_NS = 'http://www.w3.org/1999/xlink'\n\n/**\n * Namespace for SVG elements.\n * @type {string}\n */\nexport const SVG_NS = 'http://www.w3.org/2000/svg'\n\n/**\n * An empty object. Used as placeholder for `props` in VNode.\n * @type {{}} EMPTY_OBJECT\n */\nexport const EMPTY_OBJECT = {}\n\n/**\n * An empty array. Used for access to array methods.\n * @type {any[]} EMPTY_ARRAY\n */\nexport const EMPTY_ARRAY = []\n\n/**\n * An array to store lifecycle hooks.\n * @type {any[]} LIFECYCLE\n */\nexport const LIFECYCLE = []\n","import { EMPTY_OBJECT, EMPTY_ARRAY, TEXT_NODE } from './constants'\n\n/**\n * @typedef {Object<string, any> | {}} Props\n * @prop {Children} Props.children\n * @prop {(element: Element) => void} [Props.onmount]\n * @prop {(element: Element, oldProps: Object, newProps: Object) => void} [Props.onupdate]\n * @prop {(element: Element, done: (State) => void) => void} [Props.onunmount]\n */\n/**\n * @typedef {VNode[]} Children\n */\n/**\n * @typedef {string | number | Function} Type\n * @typedef {number | string | null} Key\n * @typedef {Object} VNode\n * @prop {Type} [type]\n * @prop {Props} [props]\n * @prop {Children} [children]\n * @prop {Element} [node]\n * @prop {Key} [key]\n * @prop {number} [flag]\n */\n/**\n * Create a virtual node with the provided properties.\n * @param {string | Function} type\n * @param {Props} props\n * @param {Children} children\n * @param {Element} node\n * @param {string | number | null} key\n * @param {number} [flag]\n * @return {VNode} VNode\n */\nexport function createVNode(\n  type,\n  props,\n  children,\n  node,\n  key = null,\n  flag = null\n) {\n  return {\n    type,\n    props,\n    children,\n    node,\n    flag,\n    key\n  }\n}\n\n/**\n * Create a virtual text node.\n * @param {string} value\n * @param {Element} [node]\n * @return {VNode} VNode\n */\nexport function createTextVNode(value, node) {\n  return createVNode(value, EMPTY_OBJECT, EMPTY_ARRAY, node, null, TEXT_NODE)\n}\n","import { RECYCLED_NODE, TEXT_NODE, EMPTY_OBJECT, LIFECYCLE } from './constants'\nimport { createTextVNode, createVNode } from './vnode'\n\n/**\n * Determin whether the old and new props are identical.\n * @typedef {import('./vnode').Props} Props\n * @param {Props} oldVProps\n * @param {Props} newVProps\n */\nfunction areNotEqual(oldVProps, newVProps) {\n  return JSON.stringify(oldVProps) !== JSON.stringify(newVProps)\n}\n\n/**\n * @typedef {import('./vnode').VNode} VNode\n */\n/**\n * Return the combination of two objects of props.\n * @param {Object<string, any>} a\n * @param {Object<string, any>} b\n */\nexport function mergeObjects(a, b) {\n  return Object.assign({}, a, b)\n}\n\n/**\n * Handle inline events.\n * @param {Event} event\n */\nfunction listener(event) {\n  this.handlers[event.type](event)\n}\n/**\n * Update the properties and attributes of a VNode based on new data.\n * @param {Element} node\n * @param {string} prop\n * @param {any} oldValue\n * @param {any} newValue\n * @param {boolean} isSVG\n * @return {void} undefined\n */\nfunction patchProperty(node, prop, oldValue, newValue, isSVG) {\n  if (prop === 'key') {\n  } else if (prop === 'style' && typeof newValue === 'object') {\n    for (let i in mergeObjects(oldValue, newValue)) {\n      const style = newValue == null || newValue[i] == null ? '' : newValue[i]\n      if (i[0] === '-') {\n        node[prop].setProperty(i, style)\n      } else {\n        node[prop][i] = style\n      }\n    }\n  } else if (prop[0] === 'o' && prop[1] === 'n') {\n    if (\n      !((node['handlers'] || (node['handlers'] = {}))[\n        (prop = prop.slice(2))\n      ] = newValue)\n    ) {\n      node.removeEventListener(prop, listener)\n    } else if (!oldValue) {\n      node.addEventListener(prop, listener)\n    }\n  } else if (\n    prop !== 'list' &&\n    prop !== 'form' &&\n    prop !== 'type' &&\n    prop !== 'draggable' &&\n    prop !== 'spellcheck' &&\n    prop in node &&\n    !isSVG\n  ) {\n    node[prop] = newValue == null ? '' : newValue\n  } else if (newValue == null || newValue === false) {\n    node.removeAttribute(prop)\n  } else {\n    node.setAttribute(prop, newValue)\n  }\n}\n\n/**\n * Create node from vnode.\n * @param {VNode} vnode\n * @param {Function[]} LIFECYCLE\n * @param {boolean} isSVG\n */\nfunction createNode(vnode, LIFECYCLE, isSVG) {\n  const type = String(vnode.type)\n  const node =\n    vnode.flag === TEXT_NODE\n      ? document.createTextNode(type)\n      : (isSVG = isSVG || type === 'svg') // eslint-disable-line no-cond-assign\n      ? document.createElementNS('http://www.w3.org/2000/svg', type)\n      : document.createElement(type)\n  const props = vnode.props\n  if (props['onmount']) {\n    LIFECYCLE.push(function() {\n      props['onmount'](node)\n    })\n  }\n\n  for (let k in props) {\n    patchProperty(/** @type {Element} */ (node), k, null, props[k], isSVG)\n  }\n\n  for (let i = 0, len = vnode.children.length; i < len; i++) {\n    node.appendChild(createNode(vnode.children[i], LIFECYCLE, isSVG))\n  }\n\n  return (vnode.node = /** @type{Element} */ (node))\n}\n\n/**\n * Get key of vnode element.\n * @param {VNode} vnode\n * @returns {null | string | number} null | string | number\n */\nfunction getKey(vnode) {\n  return vnode == null ? null : vnode.key\n}\n\n/**\n * Remove child node.\n * @param {VNode} vnode\n * @returns {Node} node\n */\nfunction removeChildren(vnode) {\n  for (let i = 0, length = vnode.children.length; i < length; i++) {\n    removeChildren(vnode.children[i])\n  }\n\n  const cb = vnode.props['ondestroy']\n  if (cb != null) {\n    cb(vnode.node)\n  }\n\n  return vnode.node\n}\n\n/**\n * Remove element from DOM.\n * @param {Node} parent\n * @param {VNode} vnode\n * @returns {void} undefined\n */\nfunction removeElement(parent, vnode) {\n  const remove = function() {\n    parent.removeChild(removeChildren(vnode))\n  }\n\n  const cb = vnode.props && vnode.props['onunmount']\n  if (cb != null) {\n    cb(vnode.node, remove)\n  } else {\n    remove()\n  }\n}\n\n/**\n * Patch element in DOM according to new props.\n * @param {Node} parent\n * @param {Node} node\n * @param {any} oldVNode\n * @param {any} newVNode\n * @param {boolean} [isSVG]\n */\nfunction patchNode(parent, node, oldVNode, newVNode, isSVG) {\n  if (oldVNode === newVNode) {\n  } else if (\n    oldVNode != null &&\n    oldVNode.flag === TEXT_NODE &&\n    newVNode.flag === TEXT_NODE\n  ) {\n    if (oldVNode.type !== newVNode.type) {\n      node.nodeValue = newVNode.type\n    }\n  } else if (oldVNode == null || oldVNode.type !== newVNode.type) {\n    node = parent.insertBefore(createNode(newVNode, LIFECYCLE, isSVG), node)\n    if (oldVNode != null) {\n      removeElement(parent, oldVNode)\n    }\n  } else {\n    let tmpVKid\n    let oldVKid\n\n    let oldKey\n    let newKey\n\n    const oldVProps = oldVNode.props\n    const newVProps = newVNode.props\n\n    const oldVKids = oldVNode.children\n    const newVKids = newVNode.children\n\n    let oldHead = 0\n    let newHead = 0\n    let oldTail = oldVKids.length - 1\n    let newTail = newVKids.length - 1\n\n    isSVG = isSVG || newVNode.type === 'svg'\n\n    for (let i in mergeObjects(oldVProps, newVProps)) {\n      if (\n        (i === 'value' || i === 'selected' || i === 'checked'\n          ? node[i]\n          : oldVProps[i]) !== newVProps[i]\n      ) {\n        patchProperty(\n          /** @type{Element} */ (node),\n          i,\n          oldVProps[i],\n          newVProps[i],\n          isSVG\n        )\n        const cb = newVProps.onupdate\n        if (cb != null) {\n          if (areNotEqual(oldVProps, newVProps)) {\n            LIFECYCLE.push(function() {\n              cb(node, oldVProps, newVProps)\n            })\n          }\n        }\n      }\n    }\n\n    while (newHead <= newTail && oldHead <= oldTail) {\n      if (\n        (oldKey = getKey(oldVKids[oldHead])) == null ||\n        oldKey !== getKey(newVKids[newHead])\n      ) {\n        break\n      }\n\n      patchNode(\n        node,\n        oldVKids[oldHead].node,\n        oldVKids[oldHead++],\n        newVKids[newHead++],\n        isSVG\n      )\n    }\n\n    while (newHead <= newTail && oldHead <= oldTail) {\n      if (\n        (oldKey = getKey(oldVKids[oldTail])) == null ||\n        oldKey !== getKey(newVKids[newTail])\n      ) {\n        break\n      }\n\n      patchNode(\n        node,\n        oldVKids[oldTail].node,\n        oldVKids[oldTail--],\n        newVKids[newTail--],\n        isSVG\n      )\n    }\n\n    if (oldHead > oldTail) {\n      while (newHead <= newTail) {\n        node.insertBefore(\n          createNode(newVKids[newHead++], LIFECYCLE, isSVG),\n          (oldVKid = oldVKids[oldHead]) && oldVKid.node\n        )\n      }\n    } else if (newHead > newTail) {\n      while (oldHead <= oldTail) {\n        removeElement(node, oldVKids[oldHead++])\n      }\n    } else {\n      let i, keyed, newKeyed\n      for (i = oldHead, keyed = {}, newKeyed = {}; i <= oldTail; i++) {\n        if ((oldKey = oldVKids[i].key) != null) {\n          keyed[oldKey] = oldVKids[i]\n        }\n      }\n\n      while (newHead <= newTail) {\n        oldKey = getKey((oldVKid = oldVKids[oldHead]))\n        newKey = getKey(newVKids[newHead])\n\n        if (\n          newKeyed[oldKey] ||\n          (newKey != null && newKey === getKey(oldVKids[oldHead + 1]))\n        ) {\n          if (oldKey == null) {\n            removeElement(node, oldVKid)\n          }\n          oldHead++\n          continue\n        }\n\n        if (newKey == null || oldVNode.flag === RECYCLED_NODE) {\n          if (oldKey == null) {\n            patchNode(\n              node,\n              oldVKid && oldVKid.node,\n              oldVKid,\n              newVKids[newHead],\n              isSVG\n            )\n            newHead++\n          }\n          oldHead++\n        } else {\n          if (oldKey === newKey) {\n            patchNode(node, oldVKid.node, oldVKid, newVKids[newHead], isSVG)\n            newKeyed[newKey] = true\n            oldHead++\n          } else {\n            if ((tmpVKid = keyed[newKey]) != null) {\n              patchNode(\n                node,\n                node.insertBefore(tmpVKid.node, oldVKid && oldVKid.node),\n                tmpVKid,\n                newVKids[newHead],\n                isSVG\n              )\n              newKeyed[newKey] = true\n            } else {\n              patchNode(\n                node,\n                oldVKid && oldVKid.node,\n                null,\n                newVKids[newHead],\n                isSVG\n              )\n            }\n          }\n          newHead++\n        }\n      }\n\n      while (oldHead <= oldTail) {\n        if (getKey((oldVKid = oldVKids[oldHead++])) == null) {\n          removeElement(node, oldVKid)\n        }\n      }\n\n      for (let i in keyed) {\n        if (newKeyed[i] == null) {\n          removeElement(node, keyed[i])\n        }\n      }\n    }\n  }\n\n  return (newVNode.node = node)\n}\n\nfunction recycleNode(node) {\n  return node.nodeType === TEXT_NODE\n    ? createTextVNode(node.nodeValue, node)\n    : createVNode(\n        node.nodeName.toLowerCase(),\n        EMPTY_OBJECT,\n        Array.prototype.map.call(node.childNodes, recycleNode),\n        node,\n        null,\n        RECYCLED_NODE\n      )\n}\n\n/**\n * Patch DOM with virtual node from functional component.\n * @param {Node} node\n * @param {VNode} vdom\n */\nexport function patch(node, vdom) {\n  if (!node['vdom']) {\n    if (vdom.props['onmount']) {\n      LIFECYCLE.push(function() {\n        vdom.props['onmount'](node)\n      })\n    }\n  }\n  const vnode = (patchNode(\n    node.parentNode,\n    node,\n    node['vdom'] || recycleNode(node),\n    vdom\n  )['vdom'] = vdom)\n  while (LIFECYCLE.length > 0) LIFECYCLE.pop()()\n  return vnode\n}\n","const hasOwnProperty = Object.prototype.hasOwnProperty\n\n/**\n * @typedef {Object} Tag\n * @prop {string} type\n * @prop {any} [data]\n */\n/**\n * @param {Tag} tag\n * @param {Object<string, Function>} handlers\n * @param {() => void} [catchAll]\n */\nfunction match(tag, handlers, catchAll) {\n  if (!tag.type) {\n    console.error(\n      \"The message you provided was not valid. Messages have the format: {type: 'whatever', data?: 'something'}\"\n    )\n    console.error('The tag you provided was:')\n    console.dir(tag)\n    return\n  }\n  return (tag => {\n    const { type, data } = tag\n    const match = hasOwnProperty.call(handlers, type) && handlers[type]\n    return match\n      ? match(data)\n      : catchAll\n      ? catchAll()\n      : console.error(\n          `The message you sent has no matching action method. Check the spelling for the message or the action method. The message type was \"${type}\".`\n        )\n  })(tag)\n}\n\n/**\n * Create a union of string tags.\n * @param {string[]} types\n * @returns {Object<string, any>} Object\n */\nfunction createUnion(types) {\n  const variants = Object.create(null)\n\n  let idx = 0\n  while (idx < types.length) {\n    const type = types[idx]\n    if (type === 'match') {\n      console.error(\n        `The message type you provided was \"match\". This cannot be used since it would override the message union's own match method. Please change it to something else, such as \"matchName\", etc.`\n      )\n    }\n    variants[type] = data => ({ type, data })\n    idx++\n  }\n\n  return { variants, match }\n}\n\n/**\n * @typedef {Object} MessageUnion\n */\n\n/**\n * Create a union of types for matching up with functions. This is used to define actions for the `update` method of a runtime program.\n * @param {...string} types\n * @returns {MessageUnion} MessageUnion\n */\nexport function union(...types) {\n  const { variants, match } = createUnion(types)\n  variants.match = match\n  return variants\n}\n","/**\n * @typedef {import('./runtime').Send} Send\n * @typedef {import('./runtime').Message} Message\n * @typedef {Object} State\n * @typedef {() => State} GetState\n * @typedef {(send?: Send, getState?: GetState) => any} Effect\n */\n/**\n * Function to batch effects together.\n * @param {...Effect} effects\n * @return {(send?: Send, getState?: GetState) => void} Function\n */\nexport const batchEffects = (...effects) => (getState, send) =>\n  effects.map(effect => effect && effect(getState, send))\n\nexport const batch = batchEffects\n","import { createVNode, createTextVNode } from './vnode'\n\n/**\n * Creates a virtual node representing an element node or text node to be created. This function must be imported into any file that contains JSX. Babel uses this function to convert JSX into JavaScript.\n * @typedef {import('./vnode').VNode} VNode\n * @param {string | Function} type\n * @param {Object.<string, any>} [props]\n * @return {VNode}\n */\nexport function h(type, props, ...children) {\n  props = props || {}\n  let node\n  const tempBox = []\n  const childNodes = []\n  let length = children.length\n  const key = props.key\n\n  while (length-- > 0) tempBox.push(children[length])\n\n  if (props.children) {\n    if (tempBox.length <= 0) {\n      tempBox.push(props.children)\n    }\n    delete props.children\n  }\n\n  while (tempBox.length > 0) {\n    if (Array.isArray((node = tempBox.pop()))) {\n      let length = node.length\n      while (length-- > 0) {\n        tempBox.push(node[length])\n      }\n    } else if (node === false || node === true || node == null) {\n    } else {\n      childNodes.push(typeof node === 'object' ? node : createTextVNode(node))\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type(props, childNodes)\n  }\n  return createVNode(type, props, childNodes, null, key)\n}\n","import { patch } from './vdom'\n\n/**\n * Render a functional component. The first argument is the component to render. This can be either a JSX tag or an `h` function. The second argument is the element to hydrate or update. During the first render, the target element is hydrated with the component provided. Further updates patch the existing element based on the virtual DOM.\n * @example\n *\n * ```\n * // Render Title tag into section:\n * render(<Title message='Hello World!'/>, 'section')\n * // Update the title component 5 seconds later:\n * setTimeout(() => {\n *   render(<Title message='Hello Everyone!'/>, 'section')\n * }, 5000)\n * ```\n * @typedef {import('./vnode').VNode} VNode\n * @param {VNode} vnode\n * @param {Element | string} target\n * @return {void} undefined\n */\nexport function render(vnode, target) {\n  if (Array.isArray(vnode)) {\n    throw 'Cannot insert Fragment tag directly into DOM.'\n  }\n  let oldTarget = ''\n  if (typeof target === 'string') {\n    oldTarget = target\n    target = document.querySelector(target)\n  }\n  if (!target) {\n    let msg = ''\n    if (oldTarget) msg = ` The selector you provided was: \"${oldTarget}\"`\n    console.error(\n      `@composi/core Error: The second parameter for render function was invalid. Check the selector you provided and make sure that it exists in the DOM before trying to render. ${msg}`\n    )\n  }\n  patch(target, vnode)\n}\n","/**\n * @typedef {Object<string, any>} Message\n * @prop {string} type\n * @prop {any} [data]\n * @typedef {(msg?: Message | Function, data?: any) => Message} Send\n * @typedef {() => State} GetState\n */\n/**\n * @typedef {any} State Simple or complex types for application state.\n */\n/**\n * @typedef {State | void} InitResult Return result of program init method.\n */\n/**\n * @typedef {Object<string, any>} Program A program to run.\n * @prop {() => InitResult} init Method to set up initial state.\n * @prop {(state: State, send?: Send) => void} view Method to present the current application state.\n * @prop {(state: State, msg?: Message, send?: Send) => any} update Method to capture messages sent from view or subscriptions. According to the message, an action will transform application state and pass it the the program view method.\n * @prop {(send?: Send, getState?: GetState) => void} [subscriptions] Method to run effects when the program starts. These run independently from the rest of the program.\n * @prop {(send?: Send, getState?: GetState) => void} [subs] Shortcut for subscriptions.\n * @prop {(state: State) => void} [done] Method to do clean up when shutting down a program.\n * @prop {Send} [send] A static send function for dispatching message to a program. Used with routers and in composition.\n */\n/**\n * The @composi/runtime.\n * @example\n *\n * ```\n * // Create a runtime program\n * const program = {\n *   // Define state:\n *   init() {\n *     return [{count: 0}]\n *   },\n *   // Define view to render.\n *   // Notice event to send message 'incr'.\n *   view(state, send) {\n *      return render(<div onclick={send('incr')}>The count is: {state.count}</div>, document.body)\n *   },\n *   // Define action to update state:\n *   update(state, msg) {\n *     if (msg === 'incr') {\n *        return [state.count++]\n *     }\n *   }\n * }\n * // Run the program:\n * run(program)\n * ```\n * @param {Program} program A program to run with five methods: `init`, `view`, `update`, `subscriptions` and `done`.\n * @return {() => void} Function to terminate runtime.\n */\nexport function run(program) {\n  let init = program.init\n  const view = program.view\n  const update = program.update\n  const subscriptions = program.subscriptions || program.subs\n  const done = program.done\n  let state\n  let isRunning = true\n  let isFirstRun = true\n  const getState = () => state\n\n  /**\n   * Send a message.\n   * @param {Message} message\n   *\n   */\n  function send(message, data) {\n    let msg = message\n    if (isRunning) {\n      /**\n       * message is a function from a tagged union that\n       * can be called to return a message object.\n       */\n      if (typeof message === 'function') {\n        msg = /** @type {Function} */ (message)(data)\n      }\n      return updateView(update(state, msg, send))\n    }\n  }\n\n  /**\n   * Expose send as static function on program object.\n   * This is to let you send messages to the program\n   * from other contexts, such as in a @composi/router action.\n   */\n  program['send'] = send\n\n  /**\n   * Handle changes to state and executing effects.\n   * @param {any} update\n   * @return {void} undefined\n   */\n  function updateView(update) {\n    if (update) {\n      state = update\n    } else if (init) {\n      state = init()\n    }\n    if (subscriptions && isFirstRun) {\n      if (typeof subscriptions === 'function') subscriptions(send, getState)\n      isFirstRun = false\n    }\n    view(state, send)\n  }\n  updateView(state)\n\n  /**\n   * Function to end runtime.\n   * @return {void} undefined\n   */\n  return () => {\n    if (isRunning) {\n      isRunning = false\n      if (done) {\n        done(state)\n      }\n    }\n  }\n}\n","/**\n * Returns a group of sibling elements for inclusion in another JSX tag.\n * @typedef {import('./vnode').VNode} VNode\n * @typedef {import('./vnode').Props} Props\n * @typedef {import('./vnode').Children} Children\n * @param {Props} props\n * @return {Children} children\n */\n/**\n * A tag to enable returning sibling elements. This is useful for returning list items to render in a list or table cells to render in a table row.\n * @example\n *\n * ```\n * <Fragment>\n *   <li>A</li>\n *   <li>B</li>\n *   <li>C</li>\n * </Fragment>\n ```\n * Or functionally:\n * ```\n * Fragment(null, [\n *   h('li', {}, 'A'),\n *   h('li', {}, 'B'),\n *   h('li', {}, 'C')\n * ])\n ```\n * @param {Object} [props] When using Fragment as a function, props is the first argument. Provide either null or {} as the value for props.\n * @param {Children} [children] The siblings to return with the Fragment. This will be an array of sibling elements.\n * @return {VNode[]} An array of virtual nodes.\n */\nexport const Fragment = (props, children) =>\n  Array.isArray(props) && !children ? props : children\n"],"names":["RECYCLED_NODE","TEXT_NODE","EMPTY_OBJECT","EMPTY_ARRAY","LIFECYCLE","createVNode","type","props","children","node","key","flag","createTextVNode","value","areNotEqual","oldVProps","newVProps","JSON","stringify","mergeObjects","a","b","Object","assign","listener","event","handlers","patchProperty","prop","oldValue","newValue","isSVG","i","style","setProperty","slice","addEventListener","removeEventListener","removeAttribute","setAttribute","createNode","vnode","String","document","createTextNode","createElementNS","createElement","push","k","len","length","appendChild","getKey","removeElement","parent","remove","removeChild","removeChildren","cb","recycleNode","nodeType","nodeValue","nodeName","toLowerCase","Array","prototype","map","call","childNodes","patch","vdom","patchNode","oldVNode","newVNode","insertBefore","tmpVKid","oldVKid","oldKey","newKey","oldVKids","newVKids","oldHead","newHead","oldTail","newTail","onupdate","keyed","newKeyed","parentNode","pop","hasOwnProperty","match","tag","catchAll","data","console","error","dir","createUnion","types","variants","create","idx","batchEffects","effects","getState","send","effect","batch","tempBox","isArray","target","oldTarget","querySelector","msg","program","init","view","update","subscriptions","subs","done","state","isRunning","isFirstRun","message","updateView"],"mappings":"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"}