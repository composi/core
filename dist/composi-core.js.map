{"version":3,"file":"composi-core.js.map","sources":["../src/vnode.js","../node_modules/@composi/merge-objects/src/index.js","../src/vdom.js","../src/union.js","../src/constants.js","../src/h.js","../src/render.js","../src/runtime.js","../src/effects.js","../src/fragment.js"],"sourcesContent":["import {\n  EMPTY_OBJECT,\n  EMPTY_ARRAY,\n  TEXT_NODE,\n  RECYCLED_NODE\n} from './constants'\n\n/**\n * @typedef {Object.<string, any> | {}} Props\n * @property {Children} Props.children\n */\n/**\n * @typedef {VNode[]} Children\n */\n/**\n * @typedef {string | number | Function} Type\n * @typedef {number | string | null} Key\n * @typedef {Object.<string, any>} VNode\n * @property {Type} VNode.type\n * @property {Props} VNode.props\n * @property {Children} VNode.children\n * @property {Element} VNode.element\n * @property {Key} [VNode.key]\n * @property {number} VNode.flag\n */\n/**\n * Create a virtual node with the provided properties.\n * @param {string | Function} type\n * @param {Props} props\n * @param {Children} children\n * @param {Element} element\n * @param {string | number | null} key\n * @param {number} [flag]\n * @return {VNode} VNode\n */\nexport function createVNode(\n  type,\n  props,\n  children,\n  element,\n  key = null,\n  flag = null\n) {\n  return {\n    type,\n    props,\n    children,\n    element,\n    key,\n    flag\n  }\n}\n\n/**\n * Create a virtual text node.\n * @param {string} text\n * @param {Element} [element]\n * @return {VNode} VNode\n */\nexport function createTextVNode(text, element) {\n  if (!element) element = null\n  return createVNode(text, EMPTY_OBJECT, EMPTY_ARRAY, element, null, TEXT_NODE)\n}\n\n/**\n * Function to remove whitespace nodes from DOM element.\n * This is to avoid unnecessary inclusion of\n * whitespace nodes in virtual node when hydrating.\n * @param {Element | Node} node\n * @returns {void} undefined\n */\nfunction removeWhiteSpaceNodes(node) {\n  for (let n = 0; n < node.childNodes.length; n++) {\n    const child = node.childNodes[n]\n    if (\n      child.nodeType === 8 ||\n      (child.nodeType === 3 && !/\\S/.test(child.nodeValue))\n    ) {\n      node.removeChild(child)\n      n--\n    } else if (child.nodeType === 1) {\n      removeWhiteSpaceNodes(child)\n    }\n  }\n}\n\n/**\n * Create a virtual node represeting a DOM element and its children.\n * @param {Element} element\n * @return {VNode} VNode\n */\nexport function hydrate(element) {\n  if (typeof element === 'string') {\n    element = document.querySelector(element)\n  }\n  // Clean node before using:\n  removeWhiteSpaceNodes(element)\n\n  return element.nodeType === TEXT_NODE\n    ? createTextVNode(element.nodeValue, element)\n    : createVNode(\n        element.nodeName.toLowerCase(),\n        EMPTY_OBJECT,\n        EMPTY_ARRAY.map.call(element.childNodes, hydrate),\n        element,\n        null,\n        RECYCLED_NODE\n      )\n}\n","/**\n * Combine two objects, merging the second into the first. Any properties already existing in the first will be replaced by those of the second. Any properties in the second not in the first will be added to it.\n * This does a deep clone. Sub arrays will be cloned. If arrays consist of objects, those will be cloned. Functions will also be cloned. This also support Maps and Sets.\n * Passing in just one object will return a deep clone of it.\n *\n * @param {Object.<string, any>[]} objects One or more objects to use for merging.\n * @return {Object.<string, any>} Object.<string, any>\n */\n\nexport function mergeObjects(...objects) {\n  const FIRST_ARGUMENT = 0\n  // Add empty array or object to arguments to ensure unique clone:\n  if (Array.isArray(objects[FIRST_ARGUMENT])) {\n    objects.unshift([])\n  } else {\n    objects.unshift({})\n  }\n\n  /**\n   * Create a clone of an object or array.\n   * @param {*} object The object to clone.\n   * @return {Object<string, any>} Object<string, any>\n   */\n\n  function createClone(object, hash = new WeakMap()) {\n    // Deal with primitive types:\n    if (Object(object) !== object) return object\n    // Deal with cyclic references:\n    if (hash.has(object)) return hash.get(object)\n    const result =\n      object instanceof Date\n        ? new Date(object)\n        : object instanceof RegExp\n        ? new RegExp(object.source, object.flags)\n        : object.constructor\n        ? new object.constructor()\n        : Object.create(null)\n    hash.set(object, result)\n    if (object instanceof Map) {\n      Array.from(object, ([key, val]) =>\n        result.set(key, createClone(val, hash))\n      )\n    }\n    if (object instanceof Set) {\n      Array.from(object, val => result.add(createClone(val, hash)))\n    }\n    return Object.assign(\n      result,\n      ...Object.keys(object).map(key => ({\n        [key]: createClone(object[key], hash)\n      }))\n    )\n  }\n  // Return cloned copy of merged objects:\n  if (Array.isArray(objects[FIRST_ARGUMENT])) {\n    return objects.reduce((a, b) => Array.prototype.concat(a, createClone(b)))\n  } else if (typeof objects[FIRST_ARGUMENT] === 'object') {\n    return objects.reduce((a, b) => Object.assign(a, createClone(b)))\n  }\n}\n\nexport const cloneObject = object => mergeObjects(object)\nexport const clone = object => mergeObjects(object)\n","import {\n  RECYCLED_NODE,\n  TEXT_NODE,\n  XLINK_NS,\n  SVG_NS,\n  LIFECYCLE\n} from './constants'\nimport { mergeObjects } from '@composi/merge-objects'\n\n/**\n * Event proxy for inline events.\n * @param {Event} event\n * @return {any} any\n */\nfunction eventProxy(event) {\n  return event.currentTarget['events'][event.type](event)\n}\n\n/**\n * Get the key value of a virtual node.\n * @typedef {import('./vnode').VNode} VNode\n * @param {VNode} vnode\n * @return {string | number | null}\n */\nfunction getKey(vnode) {\n  return vnode == null ? null : vnode.key\n}\n\n/**\n * Create a map of keyed nodes.\n * @typedef {import('./vnode').Children} Children\n * @param {Children} children\n * @param {number} startCount\n * @param {number} end\n * @return {Object.<string, any>} Object.<string, any>\n */\nfunction createKeyMap(children, startCount, end) {\n  const out = {}\n  let key\n  let vnode\n\n  while (startCount <= end) {\n    if ((key = (vnode = children[startCount]).key) != null) {\n      out[key] = vnode\n    }\n    startCount++\n  }\n\n  return out\n}\n\n/**\n * Update the properties and attributes of a VNode based on new data.\n * @param {Element} element\n * @param {string} prop\n * @param {any} oldValue\n * @param {any} newValue\n * @param {boolean} isSVG\n * @return {void} undefined\n */\nfunction setProp(element, prop, oldValue, newValue, isSVG) {\n  if (prop === 'key') {\n    return\n  } else if (prop === 'style' && typeof newValue === 'object') {\n    for (let i in mergeObjects(oldValue, newValue)) {\n      const style = newValue == null || newValue[i] == null ? '' : newValue[i]\n      if (i[0] === '-') {\n        element[prop].setProperty(i, style)\n      } else {\n        element[prop][i] = style\n      }\n    }\n  } else {\n    if (prop[0] === 'o' && prop[1] === 'n') {\n      prop = prop.slice(2).toLowerCase()\n\n      if (!element['events']) element['events'] = {}\n\n      element['events'][prop] = newValue\n\n      if (newValue == null) {\n        element.removeEventListener(prop, eventProxy)\n      } else if (oldValue == null) {\n        element.addEventListener(prop, eventProxy)\n      }\n    } else {\n      let nullOrFalse = newValue == null || newValue === false\n\n      if (\n        prop !== 'list' &&\n        prop !== 'form' &&\n        prop !== 'type' &&\n        prop !== 'draggable' &&\n        prop !== 'spellcheck' &&\n        prop in element &&\n        !isSVG\n      ) {\n        element[prop] = newValue == null ? '' : newValue\n      } else if (nullOrFalse) {\n        element.removeAttribute(prop)\n      } else {\n        if (prop === 'xlink-href' || prop === 'xlinkHref') {\n          element.setAttributeNS(XLINK_NS, 'href', newValue)\n          element.setAttribute('href', newValue)\n        } else {\n          element.setAttribute(prop, newValue)\n        }\n      }\n    }\n  }\n}\n\n/**\n * Create an element, either node or text, from a VNode.\n * @typedef {Function[]} Lifecycle\n * @param {VNode} vnode\n * @param {boolean} [isSVG]\n * @return {Element} Element\n */\nfunction createElement(vnode, isSVG) {\n  let element\n  if (vnode.flag === TEXT_NODE) {\n    element = document.createTextNode(/** @type {string} */ (vnode.type))\n  } else {\n    if ((isSVG = isSVG || vnode.type === 'svg')) {\n      element = document.createElementNS(\n        SVG_NS,\n        /** @type {string} */ (vnode.type)\n      )\n    } else {\n      element = document.createElement(/** @type {string} */ (vnode.type))\n    }\n  }\n\n  const props = vnode.props\n  if (props['onmount']) {\n    LIFECYCLE.push(function() {\n      props['onmount'](element)\n    })\n  }\n  let idx = 0\n  const length = vnode.children.length\n  while (idx < length) {\n    element.appendChild(createElement(vnode.children[idx], isSVG))\n    idx++\n  }\n\n  for (let prop in props) {\n    setProp(/** @type {Element} */ (element), prop, null, props[prop], isSVG)\n  }\n\n  return (vnode.element = /** @type {Element} */ (element))\n}\n\n/**\n * Remove children from a node.\n * @param {VNode} vnode\n * @return {Element}\n */\nfunction removeChildren(vnode) {\n  let idx = 0\n  const length = vnode.children.length\n  while (idx < length) {\n    removeChildren(vnode.children[idx])\n    idx++\n  }\n\n  return vnode.element\n}\n\n/**\n * Remove an element from the DOM.\n * @param {Element} parent\n * @param {VNode} vnode\n * @return {void} undefined\n */\nfunction removeElement(parent, vnode) {\n  const done = function() {\n    parent.removeChild(removeChildren(vnode))\n  }\n\n  const cb = vnode.props && vnode.props['onunmount']\n  if (cb != null) {\n    cb(vnode.element, done)\n  } else {\n    done()\n  }\n}\n\n/**\n * Update an element based on new prop values.\n * @typedef {import('./vnode').Props} Props\n * @param {Element} element\n * @param {Props} oldProps\n * @param {Props} newProps\n * @param {boolean} isSVG\n * @return {void} undefined\n */\nfunction updateElement(element, oldProps, newProps, isSVG) {\n  for (let prop in mergeObjects(oldProps, newProps)) {\n    if (\n      (prop === 'value' || prop === 'checked' || prop === 'selected'\n        ? element[prop]\n        : oldProps[prop]) !== newProps[prop]\n    ) {\n      setProp(element, prop, oldProps[prop], newProps[prop], isSVG)\n    }\n  }\n\n  const cb =\n    element['vnode'] && element['vnode'].type === RECYCLED_NODE\n      ? newProps['onmount']\n      : newProps['onupdate']\n  if (cb != null) {\n    if (newProps['onmount']) {\n      LIFECYCLE.push(function() {\n        cb(element)\n      })\n    } else {\n      LIFECYCLE.push(function() {\n        cb(element, oldProps, newProps)\n      })\n    }\n  }\n}\n\n/**\n * Patch an element based on differences between its old VNode and its new one.\n * @param {Element} parent\n * @param {Element} element\n * @param {VNode} oldVNode\n * @param {VNode} newVNode\n * @param {boolean} [isSVG]\n * @return {VNode}\n */\nfunction patchElement(parent, element, oldVNode, newVNode, isSVG) {\n  if (parent['previousVNode'] && newVNode === parent['previousVNode']) {\n  } else if (\n    oldVNode != null &&\n    oldVNode.flag === TEXT_NODE &&\n    newVNode.flag === TEXT_NODE\n  ) {\n    if (oldVNode.type !== newVNode.type) {\n      element.nodeValue = /** @type {any} */ (newVNode.type)\n    }\n  } else if (oldVNode == null || oldVNode.type !== newVNode.type) {\n    const newElement = parent.insertBefore(\n      createElement(newVNode, isSVG),\n      element\n    )\n\n    if (oldVNode != null) removeElement(parent, oldVNode)\n\n    element = newElement\n  } else {\n    updateElement(\n      element,\n      oldVNode.props,\n      newVNode.props,\n      (isSVG = isSVG || newVNode.type === 'svg')\n    )\n\n    let savedNode\n    let childNode\n\n    let lastKey\n    let oldVNodeChildren = oldVNode.children\n    let oldVNodeChildStart = 0\n    let oldVNodeChildEnd = oldVNodeChildren.length - 1\n\n    let nextKey\n    const newVNodeChildren = newVNode.children\n    let newVNodeChildStart = 0\n    let newVNodeChildEnd = newVNodeChildren.length - 1\n\n    while (\n      newVNodeChildStart <= newVNodeChildEnd &&\n      oldVNodeChildStart <= oldVNodeChildEnd\n    ) {\n      lastKey = getKey(oldVNodeChildren[oldVNodeChildStart])\n      nextKey = getKey(newVNodeChildren[newVNodeChildStart])\n\n      if (lastKey == null || lastKey !== nextKey) break\n\n      patchElement(\n        element,\n        oldVNodeChildren[oldVNodeChildStart].element,\n        oldVNodeChildren[oldVNodeChildStart],\n        newVNodeChildren[newVNodeChildStart],\n        isSVG\n      )\n\n      oldVNodeChildStart++\n      newVNodeChildStart++\n    }\n\n    while (\n      newVNodeChildStart <= newVNodeChildEnd &&\n      oldVNodeChildStart <= oldVNodeChildEnd\n    ) {\n      lastKey = getKey(oldVNodeChildren[oldVNodeChildEnd])\n      nextKey = getKey(newVNodeChildren[newVNodeChildEnd])\n\n      if (lastKey == null || lastKey !== nextKey) break\n\n      patchElement(\n        element,\n        oldVNodeChildren[oldVNodeChildEnd].element,\n        oldVNodeChildren[oldVNodeChildEnd],\n        newVNodeChildren[newVNodeChildEnd],\n        isSVG\n      )\n\n      oldVNodeChildEnd--\n      newVNodeChildEnd--\n    }\n\n    if (oldVNodeChildStart > oldVNodeChildEnd) {\n      while (newVNodeChildStart <= newVNodeChildEnd) {\n        element.insertBefore(\n          createElement(newVNodeChildren[newVNodeChildStart++], isSVG),\n          (childNode = oldVNodeChildren[oldVNodeChildStart]) &&\n            childNode.element\n        )\n      }\n    } else if (newVNodeChildStart > newVNodeChildEnd) {\n      while (oldVNodeChildStart <= oldVNodeChildEnd) {\n        removeElement(element, oldVNodeChildren[oldVNodeChildStart++])\n      }\n    } else {\n      const lastKeyed = createKeyMap(\n        oldVNodeChildren,\n        oldVNodeChildStart,\n        oldVNodeChildEnd\n      )\n      const nextKeyed = {}\n\n      while (newVNodeChildStart <= newVNodeChildEnd) {\n        lastKey = getKey((childNode = oldVNodeChildren[oldVNodeChildStart]))\n        nextKey = getKey(newVNodeChildren[newVNodeChildStart])\n\n        if (\n          nextKeyed[lastKey] ||\n          (nextKey != null &&\n            nextKey === getKey(oldVNodeChildren[oldVNodeChildStart + 1]))\n        ) {\n          if (lastKey == null) {\n            removeElement(element, childNode)\n          }\n          oldVNodeChildStart++\n          continue\n        }\n\n        if (nextKey == null || oldVNode.flag === RECYCLED_NODE) {\n          if (lastKey == null) {\n            patchElement(\n              element,\n              childNode && childNode.element,\n              childNode,\n              newVNodeChildren[newVNodeChildStart],\n              isSVG\n            )\n            newVNodeChildStart++\n          }\n          oldVNodeChildStart++\n        } else {\n          if (lastKey === nextKey) {\n            patchElement(\n              element,\n              childNode.element,\n              childNode,\n              newVNodeChildren[newVNodeChildStart],\n              isSVG\n            )\n            nextKeyed[nextKey] = true\n            oldVNodeChildStart++\n          } else {\n            if ((savedNode = lastKeyed[nextKey]) != null) {\n              patchElement(\n                element,\n                element.insertBefore(\n                  savedNode.element,\n                  childNode && childNode.element\n                ),\n                savedNode,\n                newVNodeChildren[newVNodeChildStart],\n                isSVG\n              )\n              nextKeyed[nextKey] = true\n            } else {\n              patchElement(\n                element,\n                childNode && childNode.element,\n                null,\n                newVNodeChildren[newVNodeChildStart],\n                isSVG\n              )\n            }\n          }\n          newVNodeChildStart++\n        }\n      }\n\n      while (oldVNodeChildStart <= oldVNodeChildEnd) {\n        if (\n          getKey((childNode = oldVNodeChildren[oldVNodeChildStart++])) == null\n        ) {\n          removeElement(element, childNode)\n        }\n      }\n\n      for (let key in lastKeyed) {\n        if (nextKeyed[key] == null) {\n          removeElement(element, lastKeyed[key])\n        }\n      }\n    }\n  }\n\n  if (element) {\n    newVNode.element = element\n  }\n  return newVNode\n}\n\n/**\n * Class to throw error message when attempting to insert Fragement tag directly into DOM.\n * @return {string} message\n */\nexport class FragmentError {\n  constructor() {\n    this.message = 'Cannot insert Fragment tag directly into DOM.'\n    this.toString = function() {\n      return this.message\n    }\n  }\n}\n\n/**\n * Function to either mount an element the first time or patch it in place. This behavior depends on the value of the old VNode. If it is null, a new element will be created, otherwise it compares the new VNode with the old one and patches it.\n * @param {Element | string} container\n * @param {VNode} newVNode\n * @param {VNode} [oldVNode]\n * @return {VNode} VNode\n */\nexport function patch(oldVNode, newVNode, container) {\n  if (typeof container === 'string') {\n    container = document.querySelector(container)\n  }\n\n  if (Array.isArray(newVNode)) throw new FragmentError()\n  patchElement(container, oldVNode && oldVNode.element, oldVNode, newVNode)\n\n  if (JSON.stringify(newVNode) !== JSON.stringify(oldVNode)) {\n    while (LIFECYCLE.length > 0) LIFECYCLE.pop()()\n  }\n\n  return newVNode\n}\n","const hasOwnProperty = Object.prototype.hasOwnProperty\n\n/**\n * Create a union of string tags.\n * @param {string[]} types\n */\nfunction createUnion(types) {\n  const variants = Object.create(null)\n  let checkTag = x => x && x.type\n\n  const matcher = (handlers, catchAll) => {\n    return (tag, context) => {\n      const tagType = checkTag(tag)\n      const match = hasOwnProperty.call(handlers, tagType) && handlers[tagType]\n      return match ? match(tag.data, context) : catchAll(context)\n    }\n  }\n\n  function match(tag, handlers, catchAll) {\n    return matcher(handlers, catchAll)(tag)\n  }\n\n  let idx = 0\n  while (idx < types.length) {\n    const type = types[idx]\n    variants[type] = data => ({ type, data })\n    idx++\n  }\n\n  return { variants, match }\n}\n\n/**\n * Create a union of types for matching up with functions.\n * @param {...string} types\n */\nexport function union(...types) {\n  const { variants, match } = createUnion(types)\n  variants.match = match\n  return variants\n}\n","/**\n * Used to determine if a vnode should be recycled.\n * @type {number}\n */\nexport const RECYCLED_NODE = 0\n\n/**\n * Used in a vnode to indicate that it is a DOM node.\n * @type {number}\n */\nexport const ELEMENT_NODE = 1\n\n/**\n * Used in a vnode to indicate that it is a text node.\n * @type {number}\n */\nexport const TEXT_NODE = 3\n\n/**\n * Namespace for SVG elements with `xlink:href` attributes.\n * @type {string}\n */\nexport const XLINK_NS = 'http://www.w3.org/1999/xlink'\n\n/**\n * Namespace for SVG elements.\n * @type {string}\n */\nexport const SVG_NS = 'http://www.w3.org/2000/svg'\n\n/**\n * An empty object. Used as placeholder for `props` in VNode.\n * @type {{}} EMPTY_OBJECT\n */\nexport const EMPTY_OBJECT = {}\n\n/**\n * An empty array. Used for access to array methods.\n * @type {any[]} EMPTY_ARRAY\n */\nexport const EMPTY_ARRAY = []\n\n/**\n * An array to store lifecycle hooks.\n * @type {any[]} LIFECYCLE\n */\nexport const LIFECYCLE = []\n","import { createVNode, createTextVNode } from './vnode'\n\n/**\n * Creates a virtual node representing a node or text node to be created.\n * @typedef {import('./vnode').VNode} VNode\n * @param {string | Function} type\n * @param {Object.<string, any>} [props]\n * @return {VNode}\n */\nexport function h(type, props, ...children) {\n  props = props || {}\n  let node\n  const tempBox = []\n  const childNodes = []\n  let length = children.length\n  const key = props.key\n\n  while (length-- > 0) tempBox.push(children[length])\n\n  if (props.children) {\n    if (tempBox.length <= 0) {\n      tempBox.push(props.children)\n    }\n    delete props.children\n  }\n\n  while (tempBox.length > 0) {\n    if (Array.isArray((node = tempBox.pop()))) {\n      let length = node.length\n      while (length-- > 0) {\n        tempBox.push(node[length])\n      }\n    } else if (node === false || node === true || node == null) {\n    } else {\n      childNodes.push(typeof node === 'object' ? node : createTextVNode(node))\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type(props, childNodes)\n  } else {\n    return createVNode(type, props, childNodes, null, key)\n  }\n}\n","import { patch } from './vdom'\nimport { hydrate } from './vnode'\nimport { clone } from '@composi/merge-objects'\n\n/**\n * Render a functional component. The first argument is the component to render. This can be either a JSX tag or an `h` function. The second argument is the container to render in. An optional third argument is an element in the document loaded from the server. This will be hydrated with the component provided to render. This third argument can be a DOM referece for that element, or a valid string selector for it.\n * @example\n *\n * ```\n * // Render Title tag into section:\n * render(<Title message='Hello World!'/>, 'section')\n * // Update the title component 5 seconds later:\n * setTimeout(() => {\n *   render(<Title message='Hello Everyone!'/>, 'section')\n * }, 5000)\n * ```\n * @typedef {import('./vnode').VNode} VNode\n * @param {VNode} VNode\n * @param {Element | string} container\n * @param {Element | string} [hydrateThis]\n * @return {void} undefined\n */\nexport function render(VNode, container, hydrateThis) {\n  if (typeof container === 'string') {\n    container = document.querySelector(container)\n  } else {\n    container = container\n  }\n  if (!container) {\n    console.error(\n      '@composi/core Error: You need to provide a valid container to render the component in. Check the element or selector you provided and make sure that it exists in the DOM before trying to render.'\n    )\n    console.error(\n      `@composi/core Message: The container you provided was \"${container}\"`\n    )\n    return\n  }\n  let oldVNode\n  let previousVNode = clone(VNode)\n  if (hydrateThis) {\n    if (typeof hydrateThis === 'string') {\n      hydrateThis = document.querySelector(hydrateThis)\n    }\n    // If user tries to hydrate already rendered component,\n    // use its 'vnode' property,\n    // otherwise hydrate it.\n    oldVNode = (container && container['vnode']) || hydrate(hydrateThis)\n  } else {\n    oldVNode = container && container['vnode']\n  }\n  const vnode = patch(oldVNode, VNode, container)\n  container['vnode'] = vnode\n  container['previousVNode'] = previousVNode\n}\n","/**\n * The @composi/runtime.\n * @example\n *\n * ```\n * // Create a runtime program\n * const program = {\n *   // Define state:\n *   init() {\n *     return [{count: 0}]\n *   },\n *   // Define view to render.\n *   // Notice event to send message 'incr'.\n *   view(state, send) {\n *      return render(<div onclick={send('incr')}>The count is: {state.count}</div>, document.body)\n *   },\n *   // Define action to update state:\n *   update(state, msg) {\n *     if (msg === 'incr') {\n *        return [state.count++]\n *     }\n *   }\n * }\n * // Run the program:\n * run(program)\n * ```\n * @typedef {any} State - type any.\n * @typedef {Function} Effect - A function to execute.\n * @typedef {Object<string, any>} Program A program to run.\n * @prop {Function} Program.init\n * @prop {Function} Program.view\n * @prop {Function} Program.update\n * @prop {Function} [Program.subscriptions]\n * @prop {Function} [Program.subs] Shortcut for subscriptions.\n * @prop {Function} [Program.done]\n * @param {Program} program A program to run with four methods: `init`, `view`, `update` and `subscriptions`.\n * @return {() => void} Function to terminate runtime.\n */\nexport function run(program) {\n  const update = program.update\n  const view = program.view\n  const subscriptions = program.subscriptions || program.subs\n  const done = program.done\n  let state, effect\n  let isRunning = true\n  let isFirstRun = false\n  const getState = () => state\n\n  /**\n   * Send a message.\n   * @param {any} message A message of any type.\n   * @return {void} undefined\n   */\n  function send(message) {\n    if (isRunning) {\n      updateView(update(state, message, send))\n    }\n  }\n\n  /**\n   * Expose send as static function on program object.\n   * This is to let you send messages to the program\n   * from other contexts, such as in a @composi/router action.\n   */\n  program['send'] = send\n\n  /**\n   * Handle changes to state and executing effects.\n   * @param {any[]} update\n   * @return {void} undefined\n   */\n  function updateView(update) {\n    let sub\n    let init = program.init()\n    if (update) {\n      ;[state, effect] = update\n    } else if (init && init.length) {\n      ;[state, effect] = init\n      if (subscriptions && !isFirstRun) {\n        sub = subscriptions(getState, send)\n        if (typeof sub === 'function') sub(getState, send)\n        isFirstRun = true\n      }\n    } else {\n      state = []\n    }\n    if (effect) {\n      effect(state, send)\n    }\n    view(state, send)\n  }\n\n  updateView(state)\n\n  /**\n   * Function to end runtime.\n   * @return {void} undefined\n   */\n  return () => {\n    if (isRunning) {\n      isRunning = false\n      if (done) {\n        done(state)\n      }\n    }\n  }\n}\n","/**\n * Function to batch effects together.\n * @param {...Function} effects\n * @return {Function} Function\n */\nexport const batchEffects = (...effects) => (state, send) =>\n  effects.map(effect => effect && effect(state, send))\n","/**\n * Returns a group of sibling elements for inclusion in another JSX tag.\n * @typedef {import('./vnode').Props} Props\n * @typedef {import('./vnode').Children} Children\n * @param {Props} props\n * @return {Children} children\n */\n/**\n * A tag to enable returning sibling elements. This is useful for returning list items to render in a list or table cells to render in a table row.\n * @example\n *\n * ```\n * <Fragment>\n *   <li>A</li>\n *   <li>B</li>\n *   <li>C</li>\n * </Fragment>\n ```\n * Or functionally:\n * ```\n * Fragment(null, [\n *   h('li', {}, 'A'),\n *   h('li', {}, 'B'),\n *   h('li', {}, 'C')\n * ])\n ```\n * @param {Object} [props] When using Fragment as a function, props is the first argument. Provide either null or {} as the value for props.\n * @param {Children} [children] The siblings to return with the Fragment. This will be an array of sibling elements.\n * @return {VNode[]} An array of virtual nodes.\n */\nexport const Fragment = (props, children) =>\n  Array.isArray(props) && !children ? props : children\n"],"names":["createVNode","type","props","children","element","key","flag","createTextVNode","text","EMPTY_OBJECT","EMPTY_ARRAY","removeWhiteSpaceNodes","node","child","n","childNodes","length","nodeType","test","nodeValue","removeChild","hydrate","document","querySelector","nodeName","toLowerCase","map","call","mergeObjects","objects","createClone","object","hash","WeakMap","Object","has","get","result","Date","RegExp","source","flags","constructor","create","set","assign","keys","Array","isArray","unshift","reduce","a","b","prototype","concat","eventProxy","event","currentTarget","getKey","vnode","createKeyMap","startCount","end","out","setProp","prop","oldValue","newValue","isSVG","i","style","setProperty","slice","removeEventListener","addEventListener","removeAttribute","setAttributeNS","setAttribute","createElement","createTextNode","createElementNS","LIFECYCLE","push","idx","appendChild","removeChildren","removeElement","parent","done","cb","updateElement","oldProps","newProps","patchElement","oldVNode","newVNode","newElement","insertBefore","savedNode","childNode","lastKey","nextKey","oldVNodeChildren","oldVNodeChildStart","oldVNodeChildEnd","newVNodeChildren","newVNodeChildStart","newVNodeChildEnd","lastKeyed","nextKeyed","patch","container","FragmentError","JSON","stringify","pop","createUnion","types","variants","checkTag","x","matcher","handlers","catchAll","tag","context","tagType","match","hasOwnProperty","data","clone","message","toString","tempBox","VNode","hydrateThis","console","error","previousVNode","program","send","isRunning","updateView","update","state","sub","init","effect","subscriptions","isFirstRun","getState","view","subs","effects"],"mappings":"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"}